// services/websocketService.ts

import { Client, StompSubscription, IMessage, Frame } from '@stomp/stompjs'
import SockJS from 'sockjs-client'
import { localStorageAction } from '../../utils/storage'
import { ACCESS_TOKEN_STORAGE_KEY } from '../../constants/storagekey'

// ENV
export const { VITE_BASE_URL_CLIENT_SOCKET } = import.meta.env || {}

type SubscriptionItem = {
  stompSub: StompSubscription
  callbacks: Set<(msg: any) => void>
}

class WebSocketService {
  private client: Client | null = null
  private connected = false
  private subscriptions: Record<string, SubscriptionItem> = {}

  private isConnecting = false
  private waitingCallbacks: (() => void)[] = []
  private pendingSubscriptions: Record<string, Set<(msg: any) => void>> = {}

  connect(callback?: () => void) {
    if (this.connected) {
      console.log('‚úÖ WebSocket ƒë√£ k·∫øt n·ªëi.')
      if (callback) callback()
      return
    }

    if (this.isConnecting) {
      if (callback) this.waitingCallbacks.push(callback)
      return
    }

    this.isConnecting = true

    const token = localStorageAction.get(ACCESS_TOKEN_STORAGE_KEY)
    // if (!token) {
    //   console.error("üö® Kh√¥ng t√¨m th·∫•y token!");
    //   this.isConnecting = false;
    //   return;
    // }

    const socketURL = `${VITE_BASE_URL_CLIENT_SOCKET}/ws?token=${encodeURIComponent(token)}`
    const socket = new SockJS(socketURL)

    this.client = new Client({
      webSocketFactory: () => socket,
      reconnectDelay: 5000,
      heartbeatIncoming: 4000,
      heartbeatOutgoing: 4000,

      onConnect: (frame: Frame) => {
        console.log('‚úÖ WebSocket ƒë√£ k·∫øt n·ªëi:', frame)
        this.connected = true
        this.isConnecting = false

        if (callback) callback()
        this.waitingCallbacks.forEach((cb) => cb())
        this.waitingCallbacks = []

        // ƒêƒÉng k√Ω l·∫°i c√°c pendingSubscriptions
        Object.entries(this.pendingSubscriptions).forEach(([destination, callbacks]) => {
          callbacks.forEach((cb) => this.subscribe(destination, cb))
        })
        this.pendingSubscriptions = {}
      },

      onStompError: (frame) => {
        console.error('‚ùå STOMP Error:', frame)
      },

      onWebSocketClose: () => {
        console.warn('‚ö†Ô∏è WebSocket ƒë√≥ng k·∫øt n·ªëi.')
        this.connected = false
        this.isConnecting = false
      },
    })

    this.client.activate()
  }

  /** ƒêƒÉng k√Ω nh·∫≠n message t·ª´ 1 topic */
  subscribe(destination: string, callback: (msg: any) => void) {
    if (!this.client || !this.connected) {
      console.warn('‚è≥ WebSocket ch∆∞a k·∫øt n·ªëi, delay subscribe...')
      if (!this.pendingSubscriptions[destination]) {
        this.pendingSubscriptions[destination] = new Set()
      }
      this.pendingSubscriptions[destination].add(callback)
      this.connect(() => this.subscribe(destination, callback))
      return
    }

    if (!this.subscriptions[destination]) {
      const stompSub = this.client.subscribe(destination, (message: IMessage) => {
        let parsed
        try {
          parsed = JSON.parse(message.body)
        } catch {
          parsed = message.body
        }

        this.subscriptions[destination]?.callbacks.forEach((cb) => cb(parsed))
      })

      this.subscriptions[destination] = {
        stompSub,
        callbacks: new Set([callback]),
      }
    } else {
      this.subscriptions[destination].callbacks.add(callback) // ‚úÖ Kh√¥ng s·ª£ tr√πng v√¨ l√† Set
    }
  }

  /** H·ªßy ƒëƒÉng k√Ω 1 topic */
  unsubscribe(destination: string) {
    const sub = this.subscriptions[destination]
    if (sub) {
      sub.stompSub.unsubscribe()
      delete this.subscriptions[destination]
      console.log(`üîï Unsubscribed: ${destination}`)
    }
  }

  /** G·ª≠i tin nh·∫Øn */
  sendMessage(destination: string, message: any) {
    if (!this.client || !this.connected) {
      console.warn('üö® WebSocket ch∆∞a k·∫øt n·ªëi. Delay g·ª≠i message...')
      this.connect(() => this.sendMessage(destination, message))
      return
    }

    this.client.publish({
      destination,
      body: JSON.stringify(message),
    })
  }

  /** Ng·∫Øt k·∫øt n·ªëi ho√†n to√†n */
  disconnect() {
    if (this.client) {
      Object.keys(this.subscriptions).forEach((destination) => this.unsubscribe(destination))
      this.client.deactivate()
      this.connected = false
      this.isConnecting = false
      console.log('üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi WebSocket.')
    }
  }

  /** Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi */
  isConnected() {
    return this.connected
  }
}

export const websocketService = new WebSocketService()
